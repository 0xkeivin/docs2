---
title: "Tutorial 3: Deploying to a Live Network"
hide_title: true
sidebar_label: "Tutorial 3: Deploying to a Live Network"
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

# Tutorial 3: Deploying to a Live Network

## Overview

In previous tutorials, we've seen how to deploy and run transactions on a local network. In this tutorial, we will see how to deploy and run transactions against a real, live network.

Note that zkApps are currently available on Berkeley, Mina's public testnet, which is in its final stages of testing before mainnet. In this tutorial, we will deploy our contract to the Berkeley network.

We will reuse the same smart contract from [Tutorial 1](hello-world), the `Square` contract.

## Project setup

First, as usual, setup a new project with 
```sh
$ zk project 03-deploying-to-a-live-network
```

You can find the complete source code of this project [here](https://github.com/es92/zkApp-examples/tree/main/03-deploying-to-a-live-network).

To start, delete the default generated files by running:

```sh
rm src/Add.ts
rm src/Add.test.ts
```

And create new files:

```sh
$ zk file src/Square
$ touch src/main.ts
$ touch src/util.ts
```

Copy in `src/Square.ts` and `src/index.ts` from the first tutorial - you can find these [here](https://github.com/es92/zkApp-examples/tree/main/01-hello-world/src).

That's all for setup - let's proceed to interacting wtih Berkeley

## Deploying the smart contract

A CLI tool is provided for convenience for deploying smart contracts to networks. If you would like to see how to do this programmatically, see the file [here](https://github.com/es92/zkApp-examples/tree/main/01-hello-world/src/deploy.ts). This is useful if you need more custom account creation - say deploying a zkApp to a different key than the fee payer key, programmatically parameterizing a zkApp before initializing it, or creating a Smart Contract programmatically for users as part of an application.

### zk config

`zk config` is a tool provided for managing cli deployments. It will create a `config.json` in our project's directory, as well as a `keys`, folder, containing private and public keys for our application.

To use, run:
```sh
$ zk config
```

It will ask you to specify a name (can be anything), URL to deploy to, & fee (in
MINA) to be used when sending your deploy transaction. The URL is the Mina GraphQL API
that will receive your deploy transaction and broadcast it to the Mina network.
Note that this URL is significant because it also determines which network you're
be deploying to (e.g. QANet, Testnet, Mainnet, etc).

For Berkeley Testnet, let's use the following values:

- **Name**: `berkeley`
- **URL**: `https://proxy.berkeley.minaexplorer.com/graphql`
- **Fee**: `0.1`

:::tip
  If your project contains multiple smart contracts (e.g. `Foo` and `Bar`) that
  you intend to deploy to the same network, we recommend following a naming
  pattern such as `berkeley-foo` and `berkeley-bar` when naming your deploy
  aliases. You can change their names at anytime within `config.json`.
:::

<br/>

You will see the following output:

```sh
$ zk config

Add a new network:
✔ Choose a name (can be anything): · berkeley
✔ Set URL to deploy to: · https://proxy.berkeley.minaexplorer.com/graphql
✔ Set transaction fee to use when deploying (in MINA): · 0.1
✔ Create key pair at keys/berkeley.json
✔ Add network to config.json

Success!

Next steps:

- If this is a testnet, request tMINA at:
  https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>
- To deploy, run: `zk deploy berkeley`
```

This command also generates keys, in `keys/berkeley.json`, that we will use in our application. You can see [here](https://github.com/es92/zkApp-examples/blob/main/03-deploying-to-a-live-network/src/generate_private_key.ts) an example of generating a private key programmatically, if useful for your application.

## Request funds from the faucet

To deploy your zkApp, you will need some funds to pay for transaction fees.

To get funds on the Berkeley Testnet, use the URL that was shown from the CLI output. Visit `https://faucet.minaprotocol.com/?address=<YOUR-ADDRESS>` and click **Request**.

You will have to wait a few minutes for the next block to include your transaction, so you'll have tMINA before proceeding to the next step.

## Deploy your smart contract

To deploy your smart contract to the network, run the following command:

```sh
$ zk deploy berkeley
```

When running the deploy command, the zkApp CLI will compute a verification key for your zkApp CLI. Computing the verification key can take 1-2 minutes, so please be patient. The zkApp CLI will show you the details of the transaction such as the network name, the URL, and the smart contract that will be deployed..

Finally, enter `yes` or `y` when prompted, to confirm and send the transaction.

You will see the following output:

```sh
$ zk deploy berkeley
✔ Build project
✔ Generate build.json
✔ Choose smart contract
  Only one smart contract exists in the project: Add
  Your config.json was updated to always use this
  smart contract when deploying to this network.
✔ Generate verification key (takes 1-2 min)
✔ Build transaction
✔ Confirm to send transaction
  Are you sure you want to send (yes/no)? · y
✔ Send to network

Success! Deploy transaction sent.

Next step:
  Your smart contract will be live (or updated)
  as soon as the transaction is included in a block:
  https://berkeley.minaexplorer.com/transaction/<txn-hash>
```

After a few minutes, the transaction will be included in the next block. Visit `https://berkeley.minaexplorer.com/transaction/<txn-hash>` to see the transaction in progresss.

Once the transaction is included in a block, your smart contract is deployed!"

This means, the Mina account at this public key, now contains the verification key associated with this zkApp smart contract. 

In order for a transaction to succeed against this account, it now can either include the signature of the account holder, *or* it can include a valid proof. More instruction on deploying zkApps with custom permissions (such as alowing only proofs to modify an account), will come in a later tutorial.

When a user interacts with this smart contract by providing a proof, the proof is generated locally on the user's device, and included in a transaction. Mina checks the proof (first in consensus directly, then in its ZKP recursively), to know it is correct and matches the verification key. 

When we change our code, the verification key associated with it will change and should be redeployed using the same steps as our initial deployment

## Interacting with our Deployed Smart Contract

Let's write a script to interact with our smart contract so we can see it in action. Typically, your end users will interact with a UI that you build. We'll get to that in a future tutorial, for now we will just write a script to show how this can work. This pattern is also useful when writing server side programs that interact with zkApps.

Open up `main.ts` in a text editor. You can find the complete source for this [here](https://github.com/es92/zkApp-examples/blob/main/03-deploying-to-a-live-network/src/main.ts).

### Imports, main, and BerkeleyQANet

To start, let's add the imports, and our empty main function:
```ts
  1 import { Square } from './Square.js';
  2 import {
  3   isReady,
  4   shutdown,
  5   Field,
  6   Mina,
  7   PrivateKey,
  8   PublicKey,
  9   AccountUpdate,
 10   fetchAccount,
 11 } from 'snarkyjs';
 12
 13 (async function main() {
 14   await isReady;
 15
 16   console.log('SnarkyJS loaded')
 17
 18   // ----------------------------------------------------
 19
 20   // ----------------------------------------------------
 21
 22   console.log('Shutting down')
 23
 24   await shutdown()
 25 })();
 ```

So far nothing new - but now, let's add connecting to Berkeley. In past tutorials, we've used local blockchain, which is fast for development, but only available on one's local machine, and not decentralized. By connecting to Berkeley, we can provide smart contracts that are globally accessible, and provide strong guarantees around state due to both Mina's decentralization, and succinct state proof.

With the Ethereum Bridge (future tutorial coming), states and proofs can also be available to Ethereum and other EVM chains.

 We also set a transaction fee, which we'll use to pay for access to sending transactions and deploying smart contracts on Mina. Transaction fees in code are inputted as nano mina. We will use a 0.1 Mina fee as default (100,000,000 nano mina)

 ```ts
 ...
 18   // ----------------------------------------------------
 19
 20   const Berkeley = Mina.BerkeleyQANet(
 21     'https://proxy.berkeley.minaexplorer.com/graphql'
 22   );
 23   Mina.setActiveInstance(Berkeley);
 24
 25   let transactionFee = 100_000_000;
 26 
 27   // ----------------------------------------------------
...
 ```

 While earlier we set the active instance to a local blockchain, we are now setting the active instance to the remote Berkeley network. We are connecting to Berkeley through a GraphQL proxy, which is running a Mina node connected to the Berkeley network. 

 You can also run a Mina node locally, and instead use its GraphQL endpoint. While in other blockchains this would be very heavyweight, because Mina is succinct this is actually a reasonable option. See [here](/node-operators/getting-started) to see how to do this.

 A version of the Mina node is in the works that will run directly in the browser and within the local node process, so client side users can connect directly to Mina with full decentralization guarantees, with no intermediaries that can go down, censor access, or otherwise impact you or your users' connection to the network.

Now, add to our `main.ts`:
```ts
...
 11 } from 'snarkyjs';
 12
 13 import fs from 'fs';
 14
 15 (async function main() {
...
 27   let transactionFee = 100_000_000;
 28
 29   const configName = process.argv[2];
 30
 31   const deployerKeysFileContents = fs.readFileSync('keys/' + configName + '.json', 'utf8')
 32   const deployerPrivateKeyBase58 = JSON.parse(deployerKeysFileContents).privateKey;
 33   const deployerPrivateKey = PrivateKey.fromBase58(deployerPrivateKeyBase58);
 34
 35   const zkAppPrivateKey = deployerPrivateKey;
 36
 37   // ---------------------------------------------------
...
```

We will be using the key generated by the `zk config` tool, stored in `keys/`. The name of the key file will be provided through an argument on the command line (`process.argv[2]`). The way to run this now is:

```sh
$ npm run build && node build/src/main.js berkeley
```

Which will read keys from `keys/berkeley.json`. Public and Private Keys in Mina are commonly stored in `Base58` for easily readability. In Mina, public keys start with `B62`, and private keys start with `EKE` for easy differentiability.

Our Smart Contract is also stored on chain in this same account. So we set `zkAppPrivateKey = deployerPrivateKey`.

### Waiting for accounts to be ready

Next, we will wait for the deployer account to be ready.

To do this, we will add some helper code in `utils.ts`. You can find the full source of `utils.ts` [here](https://github.com/es92/zkApp-examples/tree/main/01-hello-world/src/utils.ts).

```ts
  1 import {
  2   isReady,
  3   shutdown,
  4   Field,
  5   Mina,
  6   PrivateKey,
  7   PublicKey,
  8   AccountUpdate,
  9   fetchAccount,
 10 } from 'snarkyjs';
 11
 12 // ========================================================
 13
 14 export const loopUntilAccountExists = async (
 15   account: PublicKey,
 16   eachTimeNotExist: () => void,
 17   isZkAppAccount: boolean = false,
 18 ) => {
 19   for (;;) {
 20     let response = await fetchAccount({ publicKey: account });
 21     let accountExists = response.error == null;
 22     if (isZkAppAccount) {
 23       accountExists = accountExists && response.account!.appState != null;
 24     }
 25     if (!accountExists) {
 26       await eachTimeNotExist();
 27       await new Promise(resolve => setTimeout(resolve, 5000))
 28     } else {
 29       // TODO add optional check that verification key is correct once this is available in SnarkyJS
 30       return response.account!;
 31     }
 32   }
 33 }
 34
 35 // ========================================================
```

This code loops every 5 seconds forever until it finds an account. To do this, it first calls `fetchAccount`, with the requested account. If the account was received as expected, then the function returns the account. Each time the account doesn't exist, the function calls a user provided function. 

Note that the current version of this code as provided will return the account when any Smart Contract is loaded into it; a future version of this tutorial and code will also check if it was the intended zkApp account, as this feature is added to SnarkyJS.

Now using this, add to our `main.ts`:

```ts
...
 13 import fs from 'fs';
 14 import { loopUntilAccountExists } from './utils.js';
 15
 16 (async function main() {
 ...
 38   // ----------------------------------------------------
 39
 40   let account = await loopUntilAccountExists(
 41     deployerPrivateKey.toPublicKey(),
 42     () => {
 43       console.log('Deployer account does not exist. ' +
 44                   'Request funds at faucet ' +
 45                   'https://faucet.minaprotocol.com/?address=' + deployerPrivateKey.toPublicKey().toBase58()
 46                  );
 47     },
 48   );
 49   console.log(`Using fee payer account with nonce ${account.nonce}, balance ${account.balance}`);
 50
 51   // ----------------------------------------------------
...
 ```

 We wait until the deployer's account exist - if it does not, we remind the user they should be going to the faucet. If you've already run `zk deploy`, then this should find the account instantly and move on to the next step. But its good practice to have, and we'll reuse it later in the code too.

Once we find the account, we print out its nonce, and its balance.

Moving on, we compile the smart contract, wait for it to have been deployed, and check if it has been initialized.

```ts
...
51   // ----------------------------------------------------
 52
 53   console.log('Compiling smart contract...');
 54   let { verificationKey } = await Square.compile();
 55
 56   const zkAppPublicKey = zkAppPrivateKey.toPublicKey();
 57   let zkapp = new Square(zkAppPublicKey);
 58
 59   // Programmatic deploy:
 60   //   Besides the CLI, you can also create accounts programmatically. This is useful if you need
 61   //   more custom account creation - say deploying a zkApp to a different key than the fee payer
 62   //   key, programmatically parameterizing a zkApp before initializing it, or creating Smart
 63   //   Contracts programmatically for users as part of an application.
 64   //await deploy(deployerPrivateKey, zkAppPrivateKey, zkAppPublicKey, zkapp, verificationKey)
 65
 66   // ----------------------------------------------------
 67
 68   let isZkAppAccount = true;
 69   let zkAppAccount = await loopUntilAccountExists(
 70     zkAppPrivateKey.toPublicKey(),
 71     () => {
 72       console.log('waiting for zkApp account to be deployed...');
 73     },
 74     isZkAppAccount,
 75   );
 76
 77   // TODO when available in the future, use isProved.
 78   const allZeros = zkAppAccount.appState!.every((f) => f.equals(Field.zero).toBoolean());
 79   const needsInitialization = allZeros;
 80
 81   // ----------------------------------------------------```
 ...
```

Note as we deployed our smart contract already with `zk deploy`, programmatic deploy is not needed. However if you would like to see how this works, or its useful for your application, see code for this [here](https://github.com/es92/zkApp-examples/tree/main/01-hello-world/src/deploy.ts).

We reuse the helper function `loopUntilAccountExists` we made in `utils.js`, and check if the zkApp has been initialized by checking if every field is zero. While this works for the Square smart contract (since it initializes to 3 and then only gets larger), it may not work for all. There is an `isProved` property on accounts that SnarkyJS will expose in the future, at which point this code and tutorial will be updated to use. 

This property starts out `false` when a contract is deployed. It is recommended that, once available, the a contract's `init` function require `isProved` to be false - while other functions require `isProved` to be true. More details will be released as this feature is made available.

### Initializing the smart contract

Next, let's make a tranasction that calls `init` on the smart contract, if the smart contract hasn't been initialized yet:

```ts
...
 79   const needsInitialization = allZeros;
 80
 81   if (needsInitialization) {
 82     console.log('initializing smart contract');
 83     // TODO
 84
 85     console.log('updated state!', zkapp.num.get().toString());
 86   }
 87
 88   let num = (await zkapp.num.get())!;
 89   console.log('current value of num is', num.toString());
 90
 91   // ----------------------------------------------------
 ...
```

Where `TODO` is we'll need to write another helper, in `utils.ts`:
```ts
...
 35 // ========================================================
 36
 37 interface ToString {
 38   toString: () => string
 39 }
 40
 41 export const makeAndSendTransaction = async <State extends ToString>(
 42   feePayerPrivateKey: PrivateKey,
 43   zkAppPublicKey: PublicKey,
 44   mutateZkApp: () => void,
 45   transactionFee: number,
 46   getState: () => State,
 47   statesEqual: (state1: State, state2: State) => boolean,
 48 ) => {
 49     // TODO
 50 }
 51
 52 // ========================================================
```

This function uses a generic type, `State`, which must have a `toString` function on it. When we use this function back in `main.ts`, `State` will simply be a `Field`.

We also take a few arguments: 
* the account the fee will be paid from
* the zkApp account the transaction is applied to
* a function that mutates the zkApp
* a transaction fee
* and functions (getState, statesEqual), to get and compare state, to know what the zkApp's state is and when it has changed.

First, let's construct the basic transaction:
```ts
...
 48 ) => {
 49   const initialState = getState();
 50
 51   // Why this line? It increments internal feePayer account variables, such as
 52   // nonce, necessary for successfully sending a transaction
 53   await fetchAccount({ publicKey: feePayerPrivateKey.toPublicKey() });
 54
 55   let transaction = await Mina.transaction(
 56     { feePayerKey: feePayerPrivateKey , fee: transactionFee },
 57     () => {
 58       mutateZkApp();
 59     }
 60   );
 61 }
 62
 63 // ========================================================
```

Note the comment on `fetchAccount` - without this, making a transaction multiple times with the same `feePayer` wouldn't work, as our local knowledge of the account wouldn't match the actual state on chain.

Next, let's prove and send our transaction:

```ts
...
 60   );
 61
 62   // fill in the proof - this can take a while...
 63   console.log('Creating an execution proof...');
 64   const time0 = Date.now();
 65   await transaction.prove();
 66   const time1 = Date.now();
 67   console.log('creating proof took', (time1 - time0)/1e3, 'seconds')
 68
 69   console.log('Sending the transaction...');
 70   const res = await transaction.send();
 71   const hash = await res.hash(); // This will change in a future version of SnarkyJS
 72   if (hash == null) {
 73     console.log('error sending transaction (see above)');
 74   } else {
 75     console.log('See transaction at', 'https://berkeley.minaexplorer.com/transaction/' + hash);
 76   }
 77 }
 78
 79 // ========================================================
```

We create a proof of the transaction, send it, and print to the console whether there was an error or where to find the transaction. Note that for now, details on RPC error are printed to the console. So while not available programatically yet, you will be able to see it there if any errors happen.

Lastly, let's wait for the state to change before returning:

```ts
...
 76   }
 77
 78   let state = getState();
 79
 80   let stateChanged = false;
 81   while (!stateChanged) {
 82     console.log('waiting for zkApp state to change... (current state: ', state.toString() + ')')
 83     await new Promise(resolve => setTimeout(resolve, 5000))
 84     await fetchAccount({ publicKey: zkAppPublicKey });
 85     state = await getState();
 86     stateChanged = !statesEqual(initialState, state);
 87   }
 88 }
 89
 90 // ========================================================
```

Here, we simply loop until the state is different than the initial state, before making and sending the transaction. This can take 3-5 minutes, with Mina's current blocktime (in rare cases longer, as Mina's block creation is currently probabilistic).

And we are done! Back in main.ts, we can use the helper function like this:
```ts
...
 14 import { loopUntilAccountExists, makeAndSendTransaction } from './utils.js';
...
 79   const needsInitialization = allZeros;
 80
 81   if (needsInitialization) {
 82     console.log('initializing smart contract');
 83     await makeAndSendTransaction(
 84       deployerPrivateKey,
 85       zkAppPublicKey,
 86       () => zkapp.init(),
 87       transactionFee,
 88       () => zkapp.num.get(),
 89       (num1, num2) => num1.equals(num2).toBoolean()
 90     );
 91
 92     console.log('updated state!', zkapp.num.get().toString());
 93   }
 94
 95   let num = (await zkapp.num.get())!;
 96   console.log('current value of num is', num.toString());
 97
 98   // ----------------------------------------------------
...
```

Note our assignments for each variable:

* `feePayerPrivateKey: deployerPrivateKey`
* `zkAppPublicKey: zkAppPublicKey` (note same as deployerPrivateKey in this example)
* `mutateZkApp: () => zkapp.init()`, (in this example, sets `num` to `3`)
* `transactionFee`,
* `getState: () => zkapp.num.get()`,
* `statesEqual: (num1, num2) => num1.equals(num2).toBoolean()`,

Importantly, also note the interaction between `fetchAccount` and `getState` in `utils.ts`:
```ts
...
 84     await fetchAccount({ publicKey: zkAppPublicKey });
 85     state = await getState();
...
```

because we declared our zkapp to use the public key `zkAppPublicKey`, whenever `fetchAccount` is called, it also updates the fields on the zkapp. This ensures when `getstate` results in `zkapp.num.get()` getting called, what we get back will actually be latest state of `num` on chain. If we didn't call `fetchAccount`, we wouldn't be getting the latest state of `num`.

### Calling update on our transaction

```ts
...
 98   // ----------------------------------------------------
 99
100   await makeAndSendTransaction(
101     deployerPrivateKey,
102     zkAppPublicKey,
103     () => zkapp.update(num.mul(num)),
104     transactionFee,
105     () => zkapp.num.get(),
106     (num1, num2) => num1.equals(num2).toBoolean()
107   );
108
109   console.log('updated state!', zkapp.num.get().toString());
110
111   // ----------------------------------------------------
112
113   console.log('Shutting down')
114
115   await shutdown();
116 })()
```

Here we reuse our `makeAndSendTransaction` function, to call the `update` function on our zkapp.

## Conclusion

We have finished building a CLI that interacts with a live network! You can also run this multiple times - and it should each time, update x to its square.

Checkout out our other tutorials and documentation to keep going!

<!--- Now let's move to the next tutorial, where we will see how to build zkApp UIs that run in the browser with a wallet. -->

