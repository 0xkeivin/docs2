---
title: "Tutorial 4: Building a zkApp in the Browser with React"
hide_title: true
sidebar_label: "Tutorial 4: Building a zkApp in the Browser with React"
---

# Tutorial 4: Building a zkApp in the Browser with React

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

## Overview

In previous tutorials, we've seen how to [write zkApps](hello-world) and [interact with them from the CLI](deploying-to-a-network).

In this tutorial, we will implement a browser react app that interacts with a smart contract running on Berkeley.

We will discuss how to setup our project, implement its functionality, and show to deploy it to github pages.

If you would like to try out the application before going through the tutorial, you can do so on an instance already deployed to a github pages [here](https://es92.github.io/zkApp-examples/index.html). Extra info is printed to the console as well when it is run, to give an idea of what it is doing internally.

### What we will build

The application we will build will implement the following:
1. Loading a PrivateKey from the page's localstorage if one exists, otherwise create one.
2. Checking if the private key has funds, and direct the user to the faucet if not.
3. Connecting to example zkapp `Add` smart contract, already deployed on berkeley at a fixed address.
4. A button that when clicked sends a transaction.
5. A button that when clicked requests the latest state of the smart contract.

Like in tutorial 3, we will provide a couple helper files, so we can focus on the react implementation itself. What is special about these helpers though, is that they use a webworker. This ensures the UI thread isn't blocked during long computations like compiling a smart contract or proving a transaction.

This example uses an RPC endpoint. An in-browser Mina node is in the works, which will provide full node level security to your users, in the browser.

While this current tutorial uses localStorage to store and manage the user's private key, a new version of SnarkyJS is in the works which will connect to Auro wallet for more persistent and secure private key management.

## Project setup

First, setup a new project with

```sh
zk project 04-zkapp-browser-ui --ui next
```

On the prompts that appear, select:
1. Do you want your NextJS project to use TypeScript? `yes`
2. Do you want to setup your project for github pages? `yes`

This will create a new project with two folders instead of just one:
* `contract`: This stores your smart contract code
* `ui`: This is where you will write your ui

We will be using the default contract (`Add`), so all we'll be doing is building it for use from our ui.

To do this, enter the contract folder, and run 
```sh
npm run build
```

In making your own zkApp, you will need to edit the contract folder, and rebuild before accessing it from your UI.

## Implementing the UI

Our React UI will have a few components. First, there is the react page itself. In addition though, there is code that uses SnarkyJS.

Because SnarkyJS code is computationally intensive, running it as usual in a script would block our browser's UI thread, causing our page to become unresponsive at times. To solve this, we will put our SnarkyJS code in a webworkers. 

This will be implemented via 2 helper files:
* `zkappWorker.ts`: The web worker code itself
* `zkappWorkerClient.ts`: Code that we run from react to interact with the web worker.

We encourage you to read this files, to understand how they work and to extend them for your own zkApp, but we will not review them in detail here, in favor of spending time on the react code.

Download these files from [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/zkappWorker.ts) and [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/zkappWorkerClient.ts), and place them in your `ui/pages` folder.

### globals.css

We will be using an `<a>` link in our application - add the following to the end of `styles/globals.css` to style the link:
```css
a {
  color: blue;
}
```

### Running the react app

To run the react app, open up two new terminals. In one, type:
```sh
npm run dev
```

And in the other, 
```sh
npm run ts-watch
```

The first of these starts hosting your application, by default at `localhost:3000`. Your browser will refresh automatically when your page has changes.

The second shows typescript errors. You can watch this as you develop to check for type errors.

### Implementing the react app

Open up `ui/pages/_app.page.tsx` in your editor. You can find the full contents for this file [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/_app.page.tsx) for reference.

Edit the contents so it looks like this:
```ts
  1 import '../styles/globals.css'
  2 import React, { useEffect, useState } from "react";
  3 import './reactCOIServiceWorker';
  4
  5 import ZkappWorkerClient from './zkappWorkerClient';
  6
  7 import {
  8   PublicKey,
  9   PrivateKey,
 10   Field,
 11 } from 'snarkyjs'
 12
 13 let transactionFee = 100_000_000;
 14
 15 export default function App() {
 16   return </div>
 17 }
 18
```

This just sets up our react project, with the imports we'll need, and an empty component.

Now, we'll add state to our app:

```ts
...
 15 export default function App() {
 16
 17   let [state, setState] = useState({
 18     zkappWorkerClient: null as null | ZkappWorkerClient,
 19     hasBeenSetup: false,
 20     accountExists: false,
 21     currentNum: null as null | Field,
 22     privateKey: null as null | PrivateKey,
 23     publicKey: null as null | PublicKey,
 24     zkappPublicKey: null as null | PublicKey,
 25     creatingTransaction: false,
 26   });
 27
 28   // -------------------------------------------------------
 29
 30   return </div>
...
```

This creates mutable state that we can reference in our UI, and update as our application runs. You can learn more about react state and useState [here](https://reactjs.org/docs/hooks-state.html).

Next, we'll add a function to setup our application:
```ts
...
 28   // -------------------------------------------------------
 29   // Do Setup
 30
 31   useEffect(() => {
 32     (async () => {
 33       if (!state.hasBeenSetup) {
 34         const zkappWorkerClient = new ZkappWorkerClient();
 35
 36         console.log('Loading SnarkyJS...');
 37         await zkappWorkerClient.loadSnarkyJS();
 38         console.log('done');
 39
 40         await zkappWorkerClient.setActiveInstanceToBerkeley();
 41
 42         // TODO
 43       }
 44     })();
 45   }, []);
 46
 47   // -------------------------------------------------------
...
```


We use the react feature "useEffect", so that this is only run once. See more on useEffect [here](https://reactjs.org/docs/hooks-effect.html). We further gate running this effect by a boolean `hasBeenSetup` so we don't run this more than once.

This is also where we setup our web worker client. This will interact with our web worker running snarkyjs code, so that that code doesn't block the UI thread.

Next, we check if there is already a private key in local storage - and if not, we save one there. We also check if the account exists on chain:

```ts
...
 40         await zkappWorkerClient.setActiveInstanceToBerkeley();
 41
 42         if (localStorage.privateKey == null) {
 43           localStorage.privateKey = PrivateKey.random().toBase58();
 44         }
 45
 46         let privateKey = PrivateKey.fromBase58(localStorage.privateKey);
 47         let publicKey = privateKey.toPublicKey();
 48
 49         console.log('using key', publicKey.toBase58());
 50
 51         console.log('checking if account exists...');
 52         const res = await zkappWorkerClient.fetchAccount({ publicKey: publicKey! });
 53         const accountExists = res.error == null;
 54
 55         // TODO
 56       }
...
```

Continuing, we load our zkApp in the web worker. We load the contract, compile it, create a instance of it at a fixed address, and get its current state:

```ts
...
 53         const accountExists = res.error == null;
 54
 55         await zkappWorkerClient.loadContract();
 56
 57         console.log('compiling zkApp');
 58         await zkappWorkerClient.compileContract();
 59         console.log('zkApp compiled');
 60
 61         const zkappPublicKey = PublicKey.fromBase58('B62qrBBEARoG78KLD1bmYZeEirUfpNXoMPYQboTwqmGLtfqAGLXdWpU');
 62
 63         await zkappWorkerClient.initZkappInstance(zkappPublicKey);
 64
 65         console.log('getting zkApp state...');
 66         await zkappWorkerClient.fetchAccount({ publicKey: zkappPublicKey })
 67         const currentNum = await zkappWorkerClient.getNum();
 68         console.log('current state:', currentNum.toString());
 69
 70         // TODO
 71       }
...
```

And lastly for this function, we update the state of the react app:

```ts
...
 68         console.log('current state:', currentNum.toString());
 69
 70         setState({
 71             ...state,
 72             zkappWorkerClient,
 73             hasBeenSetup: true,
 74             publicKey,
 75             privateKey,
 76             zkappPublicKey,
 77             accountExists,
 78             currentNum
 79         });
 80       }
 81     })();
...
```

Now that we have finished setting up our UI, we write a new effect, that waits for the account to exist, if it didn't exist before. 

If the account has been newly created for example, it will need to be funded from the faucet. We'll add in our UI later a link to request funds for users to request funds while that account does not exist.

```ts
...
 84   // -------------------------------------------------------
 85   // Wait for account to exist, if it didn't
 86
 87   useEffect(() => {
 88     (async () => {
 89       if (state.hasBeenSetup && !state.accountExists) {
 90         for (;;) {
 91           console.log('checking if account exists...');
 92           const res = await state.zkappWorkerClient!.fetchAccount({ publicKey: state.publicKey! })
 93           const accountExists = res.error == null;
 94           if (accountExists) {
 95             break;
 96           }
 97           await new Promise((resolve) => setTimeout(resolve, 5000));
 98         }
 99         setState({ ...state, accountExists: true });
100       }
101     })();
102   }, [state.hasBeenSetup]);
103
104   // -------------------------------------------------------
...
```

Moving on, we'll create functions that are triggered when a button is pressed by a user.

First, a function that will send a transaction:

```ts
...
104   // -------------------------------------------------------
105   // Send a transaction
106
107   const onSendTransaction = async () => {
108     setState({ ...state, creatingTransaction: true });
109     console.log('sending a transaction...');
110
111     await state.zkappWorkerClient!.fetchAccount({ publicKey: state.publicKey! });
112
113     await state.zkappWorkerClient!.createUpdateTransaction(state.privateKey!, transactionFee);
114
115     console.log('creating proof...');
116     await state.zkappWorkerClient!.proveUpdateTransaction();
117
118     const transactionHash = await state.zkappWorkerClient!.sendUpdateTransaction();
119
120     console.log(
121       'See transaction at https://berkeley.minaexplorer.com/transaction/' + transactionHash
122     );
123
124     setState({ ...state, creatingTransaction: false });
125   }
126
127   // -------------------------------------------------------ts
...
```

And second, a function that will get the latest zkApp state:

```ts
...
127   // -------------------------------------------------------
128   // Refresh the current state
129
130   const onRefreshCurrentNum = async () => {
131     console.log('getting zkApp state...');
132     await state.zkappWorkerClient!.fetchAccount({ publicKey: state.zkappPublicKey! })
133     const currentNum = await state.zkappWorkerClient!.getNum();
134     console.log('current state:', currentNum.toString());
135
136     setState({ ...state, currentNum });
137   }
138
139   // -------------------------------------------------------ts
...
```

Lastly, we will update the `return <div/>` placeholder we originally inserted, with a ui to show the user the state of our application:

```ts
...
139   // -------------------------------------------------------
140   // Create UI elements
141
142   let setupText = state.hasBeenSetup ? 'SnarkyJS Ready' : 'Setting up SnarkyJS...';
143   let setup = <div> { setupText } </div>
144
145   let accountDoesNotExist;
146   if (state.hasBeenSetup && !state.accountExists) {
147     const faucetLink = "https://faucet.minaprotocol.com/?address=" + state.publicKey!.toBase58();
148     accountDoesNotExist = <div>
149       Account does not exist. Please visit the faucet to fund this account
150       <a href={faucetLink} target="_blank" rel="noreferrer"> [Link] </a>
151     </div>
152   }
153
154   let mainContent;
155   if (state.hasBeenSetup && state.accountExists) {
156     mainContent = <div>
157       <button onClick={onSendTransaction} disabled={state.creatingTransaction}> Send Transaction </button>
158       <div> Current Number in zkApp: { state.currentNum!.toString() } </div>
159       <button onClick={onRefreshCurrentNum}> Get Latest State </button>
160     </div>
161   }
162
163   return <div>
164    { setup }
165    { accountDoesNotExist }
166    { mainContent }
167   </div>
168 }
```

We divide our UI into 3 sections:

* `setup` lets the user know when the zkapp has finished loading.
* `accountDoesNotExist` gives the user a link to the faucet if their account hasn't been funded.
* `mainContent` shows the current state of the zkApp, and buttons to interact with it.

The buttons allow the user to create a transaction, or refresh the current state of the application, by triggering the `onSendTransaction` and `onRefreshCurrentNum` functions we wrote above.

And that's it! We've finished the code for our application. 

If you've been using `npm run dev`, you should now be able to interact with this application on `localhost:3000`, with all the functionality we've implemented over the tutorial.

## Deploying the UI to github pages

To deploy our project to github, first push it to a new github repo. The github repo must have the same name as the project name when we ran zk project above (in this example, `04-zkapp-browser-ui`). If not, change the existing project name strings in `next.config.js`, and `pages/reactCOIServiceWorker.ts` to your repo name.

To deploy, just run `npm run deploy`. After the script builds your application, uploads it to github, and github processes it, your application will be available at:
```
https://<username>.github.io/<repo-name>/index.html
```

## Conclusion

We have built an in browser react app, that interacts with a live network! You should now be ready to build your own in browser zkApp UI.

Checkout out our other tutorials and documentation to keep going!

<!-- Now let's move to the next tutorial, where we will learn about different SnarkyJS types you can use in your application. -->

