---
title: "Tutorial 4: Building a zkApp in the Browser with React"
hide_title: true
sidebar_label: "Tutorial 4: Building a zkApp in the Browser with React"
---

# Tutorial 4: Building a zkApp in the Browser with React

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but
zkApps can now be deployed to Berkeley Testnet.

:::

## Overview

In previous tutorials, we've seen how to [write zkApps](hello-world) and [interact with them from the CLI](deploying-to-a-network).

In this application, we will implement a browser app that interacts with a smart contract running on Berkeley.

We will setup the application, implement it, and show how to deploy it to github pages. 

The application will implement the following:
1. Load a PrivateKey from the page's localstorage if one exists, otherwise create one.
2. Check if the private key has funds, and direct the user to the faucet if not.
3. Connect to an example zkapp `Add` smart contract, already deployed on berkeley at a fixed address.
4. Implement a button that when clicked sends a transaction.
5. Implement a button that when clicked requests the latest state of the smart contract.

If you would like to try out the application before going through the tutorial, you can do so on an instance already deployed to a github pages [here](https://es92.github.io/zkApp-examples/index.html). Extra info is printed to the console as well when it is run, to give an idea of what it is doing internally.

Like in tutorial 3, we will provide a couple helper files, so we can focus on the react implementation itself. What is special about these helpers though, is that they use a webworker. This ensures the UI thread isn't blocked during long computations like compiling a smart contract or proving a transaction.

This example uses an RPC endpoint. An in-browser Mina node is in the works, which will provide full node level security to your users, in the browser.

While this current tutorial uses localStorage to store and manage the user's private key, a new version of SnarkyJS is in the works which will connect to Auro wallet for more persistent and secure private key management.

## Project setup

First, setup a new project with

```sh
zk project 04-zkapp-browser-ui --ui
```

On the prompts that appear, select:
1. Create an accompanying UI project too? `next`
2. Do you want your NextJS project to use TypeScript? `yes`
3. Do you want to setup your project for github pages? `yes`

This will create a new project with two folders instead of just one:
* `contract`: This stores your smart contract code
* `ui`: This is where you will write your ui

Enter the contract folder, and run 
```sh
npm run build
```

We will be using the default contract (`Add`), so all we'll be doing is building it for use from our ui.

## Implementing the UI

### Helper files

As mentioned, we'll be using two helper files so we can focus this tutorial on setting up the UI and writing the react implementation.

These two files wrap the snarkyjs code for our example application. They also do this in a web worker, to avoid blocking the ui thread during large computations.
* `zkappWorker.ts`: The web worker code itself
* `zkappWorkerClient.ts`: Code that we run from react to interact with the web worker.

So first, get these [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/zkappWorker.ts) and [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/zkappWorkerClient.ts), and place them in your `ui/pages` folder.

### globals.css

We will be using an `<a>` link in our application - add the following to the end of `styles/globals.css` to style the link:
```css
a {
  color: blue;
}
```

### Running the react app

To run the react app, open up two new terminals. In one, type:
```sh
npm run dev
```

And in the other, 
```sh
npm run ts-watch
```

The first of these starts hosting your application, at `localhost:3000`. Your browser will refresh automatically when your page has changes.

The second shows typescript errors. You can watch this as you develop to check for type errors.

### Implementing the react app

Open up `ui/pages/_app.page.tsx` in your editor. You can find the full contents for this file [here](https://raw.githubusercontent.com/es92/zkApp-examples/main/04-zkapp-browser-ui/ui/pages/_app.page.tsx) for reference.

Edit the contents so it looks like this:
```ts
  1 import '../styles/globals.css'
  2 import React, { useEffect, useState } from "react";
  3 import './reactCOIServiceWorker';
  4
  5 import ZkappWorkerClient from './zkappWorkerClient';
  6
  7 import {
  8   PublicKey,
  9   PrivateKey,
 10   Field,
 11 } from 'snarkyjs'
 12
 13 let transactionFee = 100_000_000;
 14
 15 export default function App() {
 16   return </div>
 17 }
 18
```

This just sets up our react project, with the imports we'll need, and an empty component.

First, we'll add our state to our app:

```ts
...
 15 export default function App() {
 16
 17   let [state, setState] = useState({
 18     zkappWorkerClient: null as null | ZkappWorkerClient,
 19     hasBeenSetup: false,
 20     accountExists: false,
 21     currentNum: null as null | Field,
 22     privateKey: null as null | PrivateKey,
 23     publicKey: null as null | PublicKey,
 24     zkappPublicKey: null as null | PublicKey,
 25     creatingTransaction: false,
 26   });
 27
 28   // -------------------------------------------------------
 29
 30   return </div>
...
```

Next, we'll add a function to setup our application:
```ts
...
 28   // -------------------------------------------------------
 29   // Do Setup
 30
 31   useEffect(() => {
 32     (async () => {
 33       if (!state.hasBeenSetup) {
 34         const zkappWorkerClient = new ZkappWorkerClient();
 35
 36         console.log('Loading SnarkyJS...');
 37         await zkappWorkerClient.loadSnarkyJS();
 38         console.log('done');
 39
 40         await zkappWorkerClient.setActiveInstanceToBerkeley();
 41
 42         // TODO
 43       }
 44     })();
 45   }, []);
 46
 47   // -------------------------------------------------------
...
```


We use the react feature "useEffect", so that this is only run once. We further gate this by a boolean `hasBeenSetup` so we don't run this more than once.

This is also where we setup our web worker client. This will interact with our web worker running snarkyjs code, so that code doesn't block the UI thread.

Next, we check if there is already a private key in local storage - and if not, we save one there. We also check if the account exists:

```ts
...
 40         await zkappWorkerClient.setActiveInstanceToBerkeley();
 41
 42         if (localStorage.privateKey == null) {
 43           localStorage.privateKey = PrivateKey.random().toBase58();
 44         }
 45
 46         let privateKey = PrivateKey.fromBase58(localStorage.privateKey);
 47         let publicKey = privateKey.toPublicKey();
 48
 49         console.log('using key', publicKey.toBase58());
 50
 51         console.log('checking if account exists...');
 52         const res = await zkappWorkerClient.fetchAccount({ publicKey: publicKey! });
 53         const accountExists = res.error == null;
 54
 55         // TODO
 56       }
...
```

Continuing, we load our zkApp in the web worker. We load the contract, compile it, and create a instance of it at a fixed address, and get its current state:

```ts
...
 53         const accountExists = res.error == null;
 54
 55         await zkappWorkerClient.loadContract();
 56
 57         console.log('compiling zkApp');
 58         await zkappWorkerClient.compileContract();
 59         console.log('zkApp compiled');
 60
 61         const zkappPublicKey = PublicKey.fromBase58('B62qrBBEARoG78KLD1bmYZeEirUfpNXoMPYQboTwqmGLtfqAGLXdWpU');
 62
 63         await zkappWorkerClient.initZkappInstance(zkappPublicKey);
 64
 65         console.log('getting zkApp state...');
 66         await zkappWorkerClient.fetchAccount({ publicKey: zkappPublicKey })
 67         const currentNum = await zkappWorkerClient.getNum();
 68         console.log('current state:', currentNum.toString());
 69
 70         // TODO
 71       }
...
```

And lastly for this function, we update the state of the react app:

```ts
...
 68         console.log('current state:', currentNum.toString());
 69
 70         setState({
 71             ...state,
 72             zkappWorkerClient,
 73             hasBeenSetup: true,
 74             publicKey,
 75             privateKey,
 76             zkappPublicKey,
 77             accountExists,
 78             currentNum
 79         });
 80       }
 81     })();
...
```

Continuing, we add an effect that, once the account has been setup, waits for the account to be loaded:

```ts
...
 84   // -------------------------------------------------------
 85   // Wait for account to exist, if it didn't
 86
 87   useEffect(() => {
 88     (async () => {
 89       if (state.hasBeenSetup && !state.accountExists) {
 90         for (;;) {
 91           console.log('checking if account exists...');
 92           const res = await state.zkappWorkerClient!.fetchAccount({ publicKey: state.publicKey! })
 93           const accountExists = res.error == null;
 94           if (accountExists) {
 95             break;
 96           }
 97           await new Promise((resolve) => setTimeout(resolve, 5000));
 98         }
 99         setState({ ...state, accountExists: true });
100       }
101     })();
102   }, [state.hasBeenSetup]);
103
104   // -------------------------------------------------------
...
```

If the account has been newly created for example, it will need to be funded from the faucet. We'll add in our UI later on giving the user a link to request funds.

Next, we add a function that we will call later, that will send a transaction:

```ts
...
104   // -------------------------------------------------------
105   // Send a transaction
106
107   const onSendTransaction = async () => {
108     setState({ ...state, creatingTransaction: true });
109     console.log('sending a transaction...');
110
111     await state.zkappWorkerClient!.fetchAccount({ publicKey: state.publicKey! });
112
113     await state.zkappWorkerClient!.createUpdateTransaction(state.privateKey!, transactionFee);
114
115     console.log('creating proof...');
116     await state.zkappWorkerClient!.proveUpdateTransaction();
117
118     const transactionHash = await state.zkappWorkerClient!.sendUpdateTransaction();
119
120     console.log(
121       'See transaction at https://berkeley.minaexplorer.com/transaction/' + transactionHash
122     );
123
124     setState({ ...state, creatingTransaction: false });
125   }
126
127   // -------------------------------------------------------ts
...
```

And a function that we will call later, that will update the react state:

```ts
...
127   // -------------------------------------------------------
128   // Refresh the current state
129
130   const onRefreshCurrentNum = async () => {
131     console.log('getting zkApp state...');
132     await state.zkappWorkerClient!.fetchAccount({ publicKey: state.zkappPublicKey! })
133     const currentNum = await state.zkappWorkerClient!.getNum();
134     console.log('current state:', currentNum.toString());
135
136     setState({ ...state, currentNum });
137   }
138
139   // -------------------------------------------------------ts
...
```

And lastly, code to replace our `return <div/>`, that shows a ui that updates the user with the state of our application.

The ui lets the user know when the zkapp has finished loading - and gives the user a link to the faucet if their account hasn't been funded.

Once the zkapp has finished loading, the user is presented with two buttons, allowing the user to create a transaction, or refresh the current state of the application:

```ts
...
139   // -------------------------------------------------------
140   // Create UI elements
141
142   let setupText = state.hasBeenSetup ? 'SnarkyJS Ready' : 'Setting up SnarkyJS...';
143   let setup = <div> { setupText } </div>
144
145   let accountDoesNotExist;
146   if (state.hasBeenSetup && !state.accountExists) {
147     const faucetLink = "https://faucet.minaprotocol.com/?address=" + state.publicKey!.toBase58();
148     accountDoesNotExist = <div>
149       Account does not exist. Please visit the faucet to fund this account
150       <a href={faucetLink} target="_blank" rel="noreferrer"> [Link] </a>
151     </div>
152   }
153
154   let mainContent;
155   if (state.hasBeenSetup && state.accountExists) {
156     mainContent = <div>
157       <button onClick={onSendTransaction} disabled={state.creatingTransaction}> Send Transaction </button>
158       <div> Current Number in zkApp: { state.currentNum!.toString() } </div>
159       <button onClick={onRefreshCurrentNum}> Get Latest State </button>
160     </div>
161   }
162
163   return <div>
164    { setup }
165    { accountDoesNotExist }
166    { mainContent }
167   </div>
168 }
```

And that's it! We've finished the code for our application. 

## Pushing the project to github

To deploy our project to github, first push it to a new github repo. The github repo must have the same name as the project name when we ran zk project above (in this example, `04-zkapp-browser-ui`). If not, change the existing project name strings in `next.config.js`, and `pages/reactCOIServiceWorker.ts` to your repo name.

To deploy, just run `npm run deploy`. It will take a minute, but after your application will be available at
```
https://<username>.github.io/<repo-name>/index.html
```

## Conclusion

We have built an in browser react app, that interacts with a live netowrk! If you want to build your own in browser zkApp UI, this should serve as a good starting point. 

Checkout out our other tutorials and documentation to keep going!

<!-- Now let's move to the next tutorial, where we will learn about different SnarkyJS types you can use in your application. -->

